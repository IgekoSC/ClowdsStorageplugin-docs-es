<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Lista de funciones - My Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">My Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../Advertencia/">Advertencia</a>
                    </li>
                
                
                
                    <li >
                        <a href="../Anexo1/">Anexo1</a>
                    </li>
                
                
                
                    <li >
                        <a href="../Anexo2/">Anexo2</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Lista de funciones</a>
                    </li>
                
                
                </ul>
            

            
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                
                <li >
                    <a rel="next" href="../Anexo2/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li class="disabled">
                    <a rel="prev" >
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                
            </ul>
            
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#lista-de-funciones">Lista de Funciones</a></li>
        
            <li><a href="#getchanges">getChanges()</a></li>
        
            <li><a href="#downloadfileqstring-remotepath-qstring-localpath">downloadFile(QString remotePath, QString localPath)</a></li>
        
            <li><a href="#uploadfileqstring-remotepath-qstring-localpath">uploadFile(QString remotePath, QString localPath)</a></li>
        
            <li><a href="#movefileqstring-from-qstring-to">moveFile(QString from, QString to)</a></li>
        
            <li><a href="#movedirqstring-from-qstring-to">moveDir(QString from, QString to)</a></li>
        
            <li><a href="#rmfileqstring-path">rmFile(QString path)</a></li>
        
            <li><a href="#mkdirqstring-path">mkDir(QString path)</a></li>
        
            <li><a href="#rmdirqstring-path">rmDir(QString path)</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="lista-de-funciones">Lista de Funciones</h1>
<h3 id="getchanges">getChanges()</h3>
<p>Esta es la función principal del Plug-in, la más importante, y normalmente la que más código dedica. Su cometido es el de recibir información de los sucesos de la nube, procesar esos eventos, y traducirlos en cambios de Clowds (CloudStorageChange), para que el programa sepa qué hacer con ellos. 
Devuelve un  <code>QHash&lt;QString, QList&lt;CloudStorageChange&gt; &gt;</code></p>
<p>el cual contendrá un registro de los cambios que se van a realizar. La clave será la ruta del fichero en <code>Qstring</code>, y su valor un <code>CloudStorageChange</code>, que es el cambio que ha sufrido.</p>
<p>El primer paso será hacer la petición HTTP para obtener la lista de los eventos ocurridos en la nube e ir guardándolos en un QHash, por ejemplo allEvents (ver ANEXO 2). Lo importante es que el QHash almacene los metadatos (normalmente en JSON).</p>
<p>En el caso de que la nube pueda devolver más de un cambio por archivo, una buena manera de tratar esta lista de cambios sería hacer otro QHash, como myChanges (Ver ANEXO 2), en el que en cada valor almacene un QMap. Este QMap sería una lista de los eventos (metadatos), indexada por fecha.</p>
<p><code>QHash &lt; file_ID, QMap&lt;fecha, evento&gt; &gt;</code></p>
<p>Con esto se conseguirá que por cada fichero haya una lista de todos sus cambios ordenados cronológicamente.</p>
<p>La mecánica será recorrer todos esos cambios ordenados por fecha para ir procesando por cada fichero sus cambios uno a uno, del más antiguo al más reciente. Según los metadatos de cada evento, debemos ir asignando las 'Flags' en función de qué clase de evento se trate: subir o crear es 'New', renombrar o mover es 'Moved', etc.</p>
<h3 id="downloadfileqstring-remotepath-qstring-localpath">downloadFile(QString remotePath, QString localPath)</h3>
<p>Esta función descarga desde la nube cada archivo que Clowds considere que debe descargar al sincronizar.</p>
<p>Aquí sólo debes preocuparte de introducir la petición HTTP que requiera el sistema que estemos implementando para hacer la descarga de un sólo archivo.</p>
<p>Hay que tener en cuenta que cada vez que Clowds ejecute la función, pasará por parámetro las variables remotePath y localPath. Generalmente son iguales, salvo que el sistema con el que estemos trabajando cifre los directorios. En ese caso, remotePath estará cifrada. El único momento en el que se ha de utilizar localPath, es cuando le indicamos la ruta de descarga.
Para descargar el archivo:
resources_-&gt;shrGet(QUrl, QFile);
        QUrl - URL de la petición.
        QFile - El archivo que se descargará en la carpeta de sincronización.
Dependiendo del sistema con el que estemos trabajando, es posible que se requieran cabeceras, o parámetros en la URL.</p>
<h3 id="uploadfileqstring-remotepath-qstring-localpath">uploadFile(QString remotePath, QString localPath)</h3>
<p>Esta función se encarga de subir los archivos que Clowds detecte como 'new'  en la carpeta de sincronización. Al sincronizar Clowds, se encargará de subir a la nube los archivos creados en local.</p>
<p>Recordemos que cada vez que Clowds ejecute la función, pasará por parámetro las variables remotePath y localPath. Generalmente son iguales, salvo que el sistema con el que estemos trabajando cifre los directorios. En ese caso, remotePath estará cifrada. El único momento en el que se ha de utilizar localPath, es cuando le indicamos la ruta donde está el fichero local que se desea subir.</p>
<p>Normalmente, los archivos se suben mediante Multipart-POST.
resources-&gt;shrPost(QUrl, QMap, QFile);
QUrl - URL de la petición HTTP POST para subir un fichero.
QMap - Parámetros que pueda requerir la petición HTTP, normalmente datos sobre el fichero que va a ser subido.
QFile - Archivo a subir.</p>
<p>Es posible que alguna nube requiera el uso del verbo PUT para subir archivos, en vez de POST. La implementación que Clowds suministra es
<code>resources-&gt;shrPut(QUrl url, QFile *localFile, qint64 chunkIndex = -1, qint64 chunkSize = 10485760);</code></p>
<h3 id="movefileqstring-from-qstring-to">moveFile(QString from, QString to)</h3>
<p>Mueve un archivo en la nube que había sido movido en la carpeta de sincronización.
Parámetros:</p>
<ul>
<li>from - ruta local anterior del archivo.</li>
<li>to - ruta local nueva del archivo.</li>
</ul>
<p>Hacer la petición HTTP correspondiente. Si no hay una petición exclusiva para mover un archivo, normalmente se hace actualizando la información del archivo, cambiando su padre (posiblemente el ID del padre).</p>
<ul>
<li>GET → <code>resources-&gt;shrGet();</code></li>
<li>POST → <code>resources-&gt;shrPost();</code></li>
<li>Otro verbo → <code>resources→shrSendCustomRequest();</code></li>
</ul>
<p>Se podría guardar el resultado de esta petición en un QByteArray para confirmar que se ha movido el archivo:</p>
<p><code>QByteArray result = resources-&gt;shrSendCustomRequest();</code></p>
<p>En caso de que se haya realizado con éxito devolver true; en otro caso, false.</p>
<h3 id="movedirqstring-from-qstring-to">moveDir(QString from, QString to)</h3>
<p>Mueve un directorio en la nube que había sido movido en la carpeta de sincronización.
Parámetros:</p>
<ul>
<li>from - ruta local anterior del directorio.</li>
<li>to - ruta local nueva del directorio.</li>
</ul>
<p>Hacer la petición HTTP correspondiente. Si no hay una petición exclusiva para mover un directorio, normalmente se hace actualizando la información del archivo, cambiando su padre (posiblemente el ID del padre).</p>
<ul>
<li>GET → <code>resources-&gt;shrGet();</code></li>
<li>POST → <code>resources-&gt;shrPost();</code></li>
<li>Otro verbo → <code>resources→shrSendCustomRequest();</code></li>
</ul>
<p>Nos puede interesar guardar el resultado de esta petición en un QByteArray para confirmar que se ha movido el directorio:
<code>QByteArray result = resources-&gt;shrSendCustomRequest();</code></p>
<p>En caso de que se haya realizado con éxito devolver true; en otro caso, false.</p>
<h3 id="rmfileqstring-path">rmFile(QString path)</h3>
<p>Borra un archivo en la nube que ha sido borrado en la carpeta de sincronización. La mayoría de servicios por defecto lo envían a la papelera. Siempre que tengamos la posibilidad, se recomienda usar la papelera para eliminar archivos, en vez de borrarlos directamente, para no poner en riesgo los archivos importantes de los usuarios.
Parámetros:</p>
<ul>
<li>path - La ruta del archivo local que ha sido eliminado.</li>
</ul>
<p>Hacer la petición HTTP correspondiente, usando una de estas funciones, según el caso:</p>
<ul>
<li>GET → resources-&gt;shrGet();</li>
<li>POST → resources-&gt;shrPost();</li>
<li>Otro verbo → resources-&gt;shrSendCustomRequest();</li>
</ul>
<p>Generalmente, se usa el verbo DELETE para borrar archivos. Por ejemplo:</p>
<p><code>resources_-&gt;shrSendCustomRequest(“DELETE”,     QUrl(http://www.example.org/endpoint));</code></p>
<p>Nos puede interesar guardar el resultado de esta petición en un QByteArray para confirmar que se ha borrado el archivo:</p>
<p><code>QByteArray result = resources-&gt;shrSendCustomRequest();</code></p>
<p>En caso de que se haya realizado con éxito devolver true; en otro caso, false.</p>
<p>Es probable que necesites información del archivo a borrar, la cual podrás obtener a través de una estructura de datos propia, como <code>filesByPath.value(path)</code> (Ver ANEXO 2).</p>
<h3 id="mkdirqstring-path">mkDir(QString path)</h3>
<p>Crea los directorios nuevos detectados por Clowds en la nube.
Parámetros:</p>
<p>path - La ruta del directorio local que ha sido creado.
NOTA: si el servicio cifra los ficheros, esta ruta estará cifrada.</p>
<p>Hacer la petición HTTP correspondiente, usando una de estas funciones, según el caso:</p>
<ul>
<li>GET → resources-&gt;shrGet();</li>
<li>POST → resources-&gt;shrPost();</li>
<li>Otro verbo → resources-&gt;shrSendCustomRequest();</li>
</ul>
<h3 id="rmdirqstring-path">rmDir(QString path)</h3>
<p>Borra un directorio en la nube que ha sido borrado en la carpeta de sincronización, la mayoría de servicios por defecto lo envían a la papelera.</p>
<p>Parámetros:
path - La ruta del directorio local que ha sido eliminado.</p>
<p>Hacer la petición HTTP correspondiente, usando una de estas funciones, según el caso:</p>
<ul>
<li>GET → resources-&gt;shrGet();</li>
<li>POST → resources-&gt;shrPost();</li>
<li>Otro verbo → resources-&gt;shrSendCustomRequest();</li>
</ul>
<p>Generalmente, se usa el verbo DELETE para borrar archivos. Por ejemplo:</p>
<p><code>resources_-&gt;shrSendCustomRequest(“DELETE”, 
    QUrl(http://www.example.org/endpoint));</code></p>
<p>Nos puede interesar guardar el resultado de esta petición en un QByteArray para confirmar que se ha borrado el directorio:</p>
<p><code>QByteArray result = resources-&gt;shrSendCustomRequest();</code></p>
<p>En caso de que se haya realizado con éxito devolver true; en otro caso, false.</p>
<p>Es probable que necesites información del directorio a borrar, la cual podrás obtener a través de una estructura de datos propia, como <code>filesByPath.value(path)</code> (Ver ANEXO 2).</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>

        <!--
        MkDocs version  : 0.12.2
        Docs Build Date : 2015-05-04 13:39:05.274905
        -->
    </body>
</html>